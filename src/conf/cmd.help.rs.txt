// WARN: This file is auto generated by flood-tide-gen
const OPTIONS_TEXT: &str = r"Ordering options:
  -r, --reverse                 reverse the result of comparisons
      --according-to <word>     sort according to <word>
  -h, --head <num>              unsort the first <num> lines.
  -t, --tail <num>              unsort the last <num> lines.

Other options:
      --color <when>            use markers to highlight the matching strings
  -e, --exp <exp>               regular expression. sort by the entires match
  -u, --unique                  output only the first line of an equal
      --max-buffer <size>       max buffer size

  -H, --help        display this help and exit
  -V, --version     display version information and exit
  -X <x-options>    x options. try -X help
";

#[repr(u8)]
#[derive(Debug, PartialEq, Eq)]
enum CmdOp {
    Reverse,
    AccordingTo,
    Head,
    Tail,
    Color,
    Exp,
    Unique,
    MaxBuffer,
    Help,
    Version,
    UcX,
}

impl std::convert::From<u8> for CmdOp {
    fn from(value: u8) -> Self {
        unsafe { std::mem::transmute(value) }
    }
}
impl CmdOp {
    pub const fn to(self) -> OptNum {
        self as OptNum
    }
}

#[rustfmt::skip]
const OPT_ARY: [Opt;11] = [
    Opt { sho: b'X', lon: "",              has: Arg::Yes, num: CmdOp::UcX.to(), },
    Opt { sho: 0u8,  lon: "according-to",  has: Arg::Yes, num: CmdOp::AccordingTo.to(), },
    Opt { sho: 0u8,  lon: "color",         has: Arg::Yes, num: CmdOp::Color.to(), },
    Opt { sho: b'e', lon: "exp",           has: Arg::Yes, num: CmdOp::Exp.to(), },
    Opt { sho: b'h', lon: "head",          has: Arg::Yes, num: CmdOp::Head.to(), },
    Opt { sho: b'H', lon: "help",          has: Arg::No,  num: CmdOp::Help.to(), },
    Opt { sho: 0u8,  lon: "max-buffer",    has: Arg::Yes, num: CmdOp::MaxBuffer.to(), },
    Opt { sho: b'r', lon: "reverse",       has: Arg::No,  num: CmdOp::Reverse.to(), },
    Opt { sho: b't', lon: "tail",          has: Arg::Yes, num: CmdOp::Tail.to(), },
    Opt { sho: b'u', lon: "unique",        has: Arg::No,  num: CmdOp::Unique.to(), },
    Opt { sho: b'V', lon: "version",       has: Arg::No,  num: CmdOp::Version.to(), },
];

#[rustfmt::skip]
const OPT_ARY_SHO_IDX: [(u8,usize);8] = [
(b'H',5),(b'V',10),(b'X',0),(b'e',3),(b'h',4),(b'r',7),(b't',8),(b'u',9),];

#[derive(Debug, Default, PartialEq, Eq)]
pub struct CmdOptConf {
    pub prog_name: String,
    //
    pub flg_reverse: bool,
    pub opt_according_to: OptAccordingToWord,
    pub opt_head: Option<usize>,
    pub opt_tail: Option<usize>,
    pub opt_color: OptColorWhen,
    pub opt_exp: String,
    pub flg_unique: bool,
    pub opt_max_buffer: OptMaxBufferSize,
    pub flg_help: bool,
    pub flg_version: bool,
    pub opt_uc_x: Vec<OptUcXParam>,
    //
    pub arg_params: Vec<String>,
}

impl flood_tide::HelpVersion for CmdOptConf {
    fn is_help(&self) -> bool {
        self.flg_help
    }
    fn is_version(&self) -> bool {
        self.flg_version
    }
}

fn value_to_string(nv: &NameVal<'_>) -> Result<String, OptParseError> {
    match nv.val {
        Some(x) => Ok(x.to_string()),
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon_or_sho())),
    }
}

fn value_to_usize(nv: &NameVal<'_>) -> Result<usize, OptParseError> {
    match nv.val {
        Some(x) => match x.parse::<usize>() {
            Ok(d) => Ok(d),
            Err(err) => Err(OptParseError::invalid_option_argument(
                &nv.opt.lon_or_sho(),
                &err.to_string(),
            )),
        },
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon_or_sho())),
    }
}

fn value_to_opt_according_to_word(nv: &NameVal<'_>) -> Result<OptAccordingToWord, OptParseError> {
    match nv.val {
        Some(s) => match FromStr::from_str(s) {
            Ok(x) => Ok(x),
            Err(err) => Err(OptParseError::invalid_option_argument(
                &nv.opt.lon_or_sho(),
                &err.to_string(),
            )),
        },
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon_or_sho())),
    }
}

fn value_to_opt_color_when(nv: &NameVal<'_>) -> Result<OptColorWhen, OptParseError> {
    match nv.val {
        Some(s) => match FromStr::from_str(s) {
            Ok(x) => Ok(x),
            Err(err) => Err(OptParseError::invalid_option_argument(
                &nv.opt.lon_or_sho(),
                &err.to_string(),
            )),
        },
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon_or_sho())),
    }
}

fn value_to_opt_max_buffer_size(nv: &NameVal<'_>) -> Result<OptMaxBufferSize, OptParseError> {
    match nv.val {
        Some(s) => match FromStr::from_str(s) {
            Ok(x) => Ok(x),
            Err(err) => Err(OptParseError::invalid_option_argument(
                &nv.opt.lon_or_sho(),
                &err.to_string(),
            )),
        },
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon_or_sho())),
    }
}

fn value_to_opt_uc_x_param(nv: &NameVal<'_>) -> Result<OptUcXParam, OptParseError> {
    match nv.val {
        Some(s) => match FromStr::from_str(s) {
            Ok(x) => Ok(x),
            Err(err) => Err(OptParseError::invalid_option_argument(
                &nv.opt.lon_or_sho(),
                &err.to_string(),
            )),
        },
        None => Err(OptParseError::missing_option_argument(&nv.opt.lon_or_sho())),
    }
}
